"""Entry point for the weekly S-C-P-C pipeline."""
from __future__ import annotations

import argparse
import logging
from dataclasses import dataclass
from typing import Any, Tuple

from scpc.cache import (
    CompetitionCacheKey,
    FeatureCache,
    GLOBAL_CACHE,
    SceneCacheKey,
)
from scpc.settings import get_deepseek_settings, get_doris_settings


logger = logging.getLogger(__name__)


@dataclass(slots=True)
class WeeklyRunResult:
    """Represents the artefacts generated by the weekly job."""

    scene: dict[str, Any]
    competition: dict[str, Any]
    parent: dict[str, Any]
    child: dict[str, Any]
    budget_plan: list[dict[str, Any]]
    report_markdown: str


def run(
    scene_id: str,
    parent_id: str,
    *,
    cache: FeatureCache | None = None,
    iso_weeks: Tuple[str, ...] | None = None,
) -> None:
    """Execute the end-to-end weekly job.

    This implementation is intentionally light-weight.  It wires together the
    feature computation, orchestrates the LLM calls and persists artefacts.
    Full persistence and LLM integrations are left for subsequent iterations.

    ``scene`` 与 ``competition`` 在一次进程生命周期内会随着父体切换而频繁复用。
    通过 ``FeatureCache`` 可以避免相同场景或竞品对重复读取与计算。
    """

    cache = cache or GLOBAL_CACHE
    weeks = iso_weeks or tuple()
    logger.info("weekly_main.start", extra={"scene_id": scene_id, "parent_id": parent_id})
    try:
        db_settings = get_doris_settings()
        llm_settings = get_deepseek_settings()
    except RuntimeError as exc:
        logger.error(
            "weekly_main.configuration_error",
            extra={"scene_id": scene_id, "parent_id": parent_id},
            exc_info=True,
        )
        raise
    logger.debug(
        "weekly_main.runtime_config",
        extra={
            "scene_id": scene_id,
            "parent_id": parent_id,
            "doris_host": db_settings.host,
            "doris_port": db_settings.port,
            "doris_db": db_settings.database,
            "deepseek_base": llm_settings.base_url,
            "deepseek_model": llm_settings.model,
        },
    )
    scene_key = SceneCacheKey(scene_id=scene_id, iso_weeks=weeks)
    scene_hit = cache.has_scene(scene_key)

    def _load_scene_features() -> dict[str, Any]:
        logger.debug(
            "weekly_main.scene_compute",
            extra={"scene_id": scene_id, "iso_weeks": weeks},
        )
        # 实际实现中会由特征层读取数据库并计算；此处返回桩结构以示例缓存行为。
        return {"scene_id": scene_id, "iso_weeks": weeks}

    cache.get_scene(scene_key, _load_scene_features)
    logger.info(
        "weekly_main.scene_cache",
        extra={
            "scene_id": scene_id,
            "iso_weeks": weeks,
            "cache_hit": scene_hit,
        },
    )

    competition_key = CompetitionCacheKey(
        parent_id=parent_id,
        iso_weeks=weeks,
        scene_id=scene_id,
    )
    competition_hit = cache.has_competition(competition_key)

    def _load_competition_features() -> dict[str, Any]:
        logger.debug(
            "weekly_main.competition_compute",
            extra={
                "scene_id": scene_id,
                "parent_id": parent_id,
                "iso_weeks": weeks,
            },
        )
        return {"scene_id": scene_id, "parent_id": parent_id, "iso_weeks": weeks}

    cache.get_competition(competition_key, _load_competition_features)
    logger.info(
        "weekly_main.competition_cache",
        extra={
            "scene_id": scene_id,
            "parent_id": parent_id,
            "iso_weeks": weeks,
            "cache_hit": competition_hit,
        },
    )
    # Placeholder; actual orchestration will be implemented incrementally.
    logger.info("weekly_main.finish", extra={"scene_id": scene_id, "parent_id": parent_id})


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Weekly S-C-P-C job")
    parser.add_argument("--scene_id", required=True)
    parser.add_argument("--parent_id", required=True)
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    run(scene_id=args.scene_id, parent_id=args.parent_id)


if __name__ == "__main__":
    main()
